<!DOCTYPE html><html lang="ko"> <head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="description" content="Gitsunmin's website | 김선민의 웹사이트"><title>thinking-in-graphs - TIL - Gitsunmin</title><link rel="icon" type="image/svg+xml" href="/favicon.svg"><meta name="astro-view-transitions-enabled" content="true"><meta name="astro-view-transitions-fallback" content="animate"><script type="module" src="/_astro/ClientRouter.astro_astro_type_script_index_0_lang.CDGfc0hd.js"></script><link rel="stylesheet" href="/_astro/blog.BVCk-ah5.css"></head> <body> <style>astro-island,astro-slot,astro-static-slot{display:contents}</style><script>(()=>{var e=async t=>{await(await t())()};(self.Astro||(self.Astro={})).only=e;window.dispatchEvent(new Event("astro:only"));})();</script><script>(()=>{var A=Object.defineProperty;var g=(i,o,a)=>o in i?A(i,o,{enumerable:!0,configurable:!0,writable:!0,value:a}):i[o]=a;var d=(i,o,a)=>g(i,typeof o!="symbol"?o+"":o,a);{let i={0:t=>m(t),1:t=>a(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(a(t)),5:t=>new Set(a(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t),11:t=>1/0*t},o=t=>{let[l,e]=t;return l in i?i[l](e):void 0},a=t=>t.map(o),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([l,e])=>[l,o(e)]));class y extends HTMLElement{constructor(){super(...arguments);d(this,"Component");d(this,"hydrator");d(this,"hydrate",async()=>{var b;if(!this.hydrator||!this.isConnected)return;let e=(b=this.parentElement)==null?void 0:b.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let c=this.querySelectorAll("astro-slot"),n={},h=this.querySelectorAll("template[data-astro-template]");for(let r of h){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("data-astro-template")||"default"]=r.innerHTML,r.remove())}for(let r of c){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("name")||"default"]=r.innerHTML)}let p;try{p=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(r){let s=this.getAttribute("component-url")||"<unknown>",v=this.getAttribute("component-export");throw v&&(s+=` (export ${v})`),console.error(`[hydrate] Error parsing props for component ${s}`,this.getAttribute("props"),r),r}let u;await this.hydrator(this)(this.Component,p,n,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});d(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),c.disconnect(),this.childrenConnectedCallback()},c=new MutationObserver(()=>{var n;((n=this.lastChild)==null?void 0:n.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});c.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}async start(){let e=JSON.parse(this.getAttribute("opts")),c=this.getAttribute("client");if(Astro[c]===void 0){window.addEventListener(`astro:${c}`,()=>this.start(),{once:!0});return}try{await Astro[c](async()=>{let n=this.getAttribute("renderer-url"),[h,{default:p}]=await Promise.all([import(this.getAttribute("component-url")),n?import(n):()=>()=>{}]),u=this.getAttribute("component-export")||"default";if(!u.includes("."))this.Component=h[u];else{this.Component=h;for(let f of u.split("."))this.Component=this.Component[f]}return this.hydrator=p,this.hydrate},e,this)}catch(n){console.error(`[astro-island] Error hydrating ${this.getAttribute("component-url")}`,n)}}attributeChangedCallback(){this.hydrate()}}d(y,"observedAttributes",["props"]),customElements.get("astro-island")||customElements.define("astro-island",y)}})();</script><script>(()=>{var e=async t=>{await(await t())()};(self.Astro||(self.Astro={})).load=e;window.dispatchEvent(new Event("astro:load"));})();</script><astro-island uid="Z22aOQ" prefix="r75" component-url="/_astro/Providers.CDrezrva.js" component-export="Providers" renderer-url="/_astro/client.9unXo8s5.js" props="{}" ssr client="load" opts="{&quot;name&quot;:&quot;Providers&quot;,&quot;value&quot;:true}" await-children><astro-slot>  <astro-island uid="2t9TGb" component-url="/_astro/Header.DohD74y_.js" component-export="Header" renderer-url="/_astro/client.9unXo8s5.js" props="{&quot;title&quot;:[0,&quot;TIL&quot;]}" ssr client="only" opts="{&quot;name&quot;:&quot;Header&quot;,&quot;value&quot;:&quot;react&quot;}"></astro-island> <main class="flex flex-col justify-center min-h-[calc(100dvh-48px)] md:min-h-[calc(100dvh-64px)] w-full">  <div class="px-6 py-4 md:py-8 md:px-0 w-full md:max-w-(--breakpoint-md) mx-auto"><h1 class="text-5xl font-bold mb-12 w-full">TIL<div class="text-xl font-normal text-gray-500 dark:text-gray-400">(=Today I Learned)</div></h1> <article class="prose dark:prose-invert max-w-none"> <h1 id="thinking-in-graphs-번역" class="text-4xl font-bold text-foreground mb-4 w-full">Thinking in Graphs <a class="text-blue-500 dark:text-blue-400 hover:underline" target="_blank" rel="noopener noreferrer" href="https://graphql.org/learn/thinking-in-graphs/">번역</a></h1>
<h2 id="층층이-쌓여있는-그래프" class="text-3xl font-semibold text-foreground mt-8 mb-4 w-full">층층이 쌓여있는 그래프</h2>
<blockquote class="border-l-4 border-gray-300 dark:border-gray-700 pl-4 italic text-gray-600 dark:text-gray-400 my-4">
<p class="text-foreground leading-relaxed mb-4 w-full">GraphQL을 사용하면 비즈니스 도메인을 Graph로 모델링할 수 있습니다.</p>
</blockquote>
<p class="text-foreground leading-relaxed mb-4 w-full">그래프는 우리의 자연스러운 정신 모델과 기본 프로세스에 대한 언어적 설명과 유사하기 때문에 많은 실제 현상을 모델링하는 데 강력한 도구입니다. GraphQL을 사용하면 스키마를 정의하여 비즈니스 도메인을 그래프로 모델링하고, 스키마 내에서 다양한 유형의 노드와 이들이 서로 연결/관련되는 방식을 정의할 수 있습니다. 클라이언트에서는 객체 지향 프로그래밍과 유사한 패턴, 즉 다른 유형을 참조하는 유형이 생성됩니다. 서버에서는 GraphQL이 인터페이스만 정의하기 때문에 모든 백엔드(신규 또는 레거시!)에서 자유롭게 사용할 수 있습니다.</p>
<h2 id="공유-언어" class="text-3xl font-semibold text-foreground mt-8 mb-4 w-full">공유 언어</h2>
<blockquote class="border-l-4 border-gray-300 dark:border-gray-700 pl-4 italic text-gray-600 dark:text-gray-400 my-4">
<p class="text-foreground leading-relaxed mb-4 w-full">어떤 것의 이름을 지정하는 것은 직관적인 API를 구축하는 데 있어 어렵지만 중요한 부분입니다.</p>
</blockquote>
<p class="text-foreground leading-relaxed mb-4 w-full">GraphQL 스키마는 팀과 사용자를 위한 표현력 있는 공유 언어라고 생각하세요. 좋은 스키마를 구축하려면 비즈니스를 설명하는 데 사용하는 일상적인 언어를 살펴보세요. 예를 들어 이메일 앱을 평이한 말로 설명해 봅시다:</p>
<ul class="list-disc list-inside mb-4 w-full">
<li class="mb-2">사용자는 여러 개의 이메일 계정을 가질 수 있습니다.</li>
<li class="mb-2">각 이메일 계정에는 주소, 받은 편지함, 임시 보관함, 삭제된 항목, 보낸 항목이 있습니다.</li>
<li class="mb-2">각 이메일에는 발신자, 수신 날짜, 제목 및 본문이 있습니다.</li>
<li class="mb-2">사용자는 받는 사람 주소가 없으면 이메일을 보낼 수 없습니다.</li>
</ul>
<p class="text-foreground leading-relaxed mb-4 w-full">이름을 짓는 것은 직관적인 API를 구축하는 데 있어 어렵지만 중요한 부분이므로, 문제 도메인과 사용자에게 적합한 이름이 무엇인지 신중하게 생각해 보세요. GraphQL 스키마에서 노드와 관계에 대해 직관적이고 내구성 있는 이름을 선택해야 하므로 팀은 이러한 비즈니스 도메인 규칙에 대한 공유된 이해와 합의를 개발해야 합니다. 실행하고자 하는 몇 가지 쿼리를 상상해 보세요:</p>
<p class="text-foreground leading-relaxed mb-4 w-full">내 모든 계정의 받은 편지함에 있는 읽지 않은 이메일 수 가져오기</p>
<div class="relative my-4 w-full group"><pre class="overflow-x-auto p-4 rounded-lg bg-gray-900 dark:bg-gray-950 shadow-lg"><code class="bg-gray-100 dark:bg-gray-800 text-red-600 dark:text-red-400 px-1 py-0.5 rounded font-mono text-sm"><span class="line"><span style="color:#E1E4E8">{</span></span>
<span class="line"><span style="color:#FFAB70">  accounts</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#FFAB70">    inbox</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#FFAB70">      unreadEmailCount</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre><button class="absolute top-2 right-2 p-2 rounded-md transition-all z-40 cursor-pointer bg-gray-700 hover:bg-gray-600 text-gray-300 hover:text-white opacity-0 group-hover:opacity-100" aria-label="Copy code" type="button"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-copy" aria-hidden="true"><rect width="14" height="14" x="8" y="8" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></div>
<p class="text-foreground leading-relaxed mb-4 w-full">메인 계정에서 처음 20개의 초안에 대한 ‘미리 보기 정보’를 가져옵니다.</p>
<div class="relative my-4 w-full group"><pre class="overflow-x-auto p-4 rounded-lg bg-gray-900 dark:bg-gray-950 shadow-lg"><code class="bg-gray-100 dark:bg-gray-800 text-red-600 dark:text-red-400 px-1 py-0.5 rounded font-mono text-sm"><span class="line"><span style="color:#E1E4E8">{</span></span>
<span class="line"><span style="color:#FFAB70">  mainAccount</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#FFAB70">    drafts</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">first</span><span style="color:#E1E4E8">: </span><span style="color:#79B8FF">20</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">      ...</span><span style="color:#FFAB70">previewInfo</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"><span style="color:#E1E4E8"> </span></span>
<span class="line"><span style="color:#F97583">fragment</span><span style="color:#B392F0"> previewInfo</span><span style="color:#F97583"> on</span><span style="color:#79B8FF"> Email</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#FFAB70">  subject</span></span>
<span class="line"><span style="color:#FFAB70">  bodyPreviewSentence</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre><button class="absolute top-2 right-2 p-2 rounded-md transition-all z-40 cursor-pointer bg-gray-700 hover:bg-gray-600 text-gray-300 hover:text-white opacity-0 group-hover:opacity-100" aria-label="Copy code" type="button"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-copy" aria-hidden="true"><rect width="14" height="14" x="8" y="8" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></div>
<h2 id="비즈니스-로직-계층" class="text-3xl font-semibold text-foreground mt-8 mb-4 w-full">비즈니스 로직 계층</h2>
<blockquote class="border-l-4 border-gray-300 dark:border-gray-700 pl-4 italic text-gray-600 dark:text-gray-400 my-4">
<p class="text-foreground leading-relaxed mb-4 w-full">비즈니스 로직 계층은 비즈니스 도메인 규칙을 적용하기 위한 단일 소스 역할을 해야 합니다.</p>
</blockquote>
<p class="text-foreground leading-relaxed mb-4 w-full">실제 비즈니스 로직을 어디에 정의해야 할까요? 유효성 검사 및 권한 확인은 어디에서 수행해야 할까요? 정답은 전용 비즈니스 로직 계층 내부입니다. 비즈니스 로직 계층은 비즈니스 도메인 규칙을 적용하기 위한 단일 소스 역할을 해야 합니다.</p>
<h2 id="레거시-데이터로-작업하기" class="text-3xl font-semibold text-foreground mt-8 mb-4 w-full">레거시 데이터로 작업하기</h2>
<blockquote class="border-l-4 border-gray-300 dark:border-gray-700 pl-4 italic text-gray-600 dark:text-gray-400 my-4">
<p class="text-foreground leading-relaxed mb-4 w-full">레거시 데이터베이스 스키마를 미러링하는 대신 클라이언트가 데이터를 사용하는 방식을 설명하는 GraphQL 스키마를 구축하는 것을 선호합니다.</p>
</blockquote>
<p class="text-foreground leading-relaxed mb-4 w-full">클라이언트가 데이터를 소비하는 방식을 완벽하게 반영하지 않는 레거시 데이터 소스로 작업하는 경우가 있습니다. 이러한 경우에는 레거시 데이터베이스 스키마를 미러링하는 대신 클라이언트가 데이터를 사용하는 방식을 설명하는 GraphQL 스키마를 구축하는 것이 좋습니다.</p>
<p class="text-foreground leading-relaxed mb-4 w-full">‘무엇’이 아닌 ‘어떻게’를 표현하도록 GraphQL 스키마를 구축하세요. 그러면 이전 클라이언트와의 인터페이스를 손상시키지 않고도 구현 세부 사항을 개선할 수 있습니다.</p>
<h2 id="one-step-at-a-time" class="text-3xl font-semibold text-foreground mt-8 mb-4 w-full">One Step at a time</h2>
<blockquote class="border-l-4 border-gray-300 dark:border-gray-700 pl-4 italic text-gray-600 dark:text-gray-400 my-4">
<p class="text-foreground leading-relaxed mb-4 w-full">더 자주 유효성 검사 및 피드백 받기</p>
</blockquote>
<p class="text-foreground leading-relaxed mb-4 w-full">전체 비즈니스 도메인을 한 번에 모델링하려고 하지 마세요. 그보다는 한 번에 하나의 시나리오에 필요한 스키마 부분만 구축하세요. 스키마를 점진적으로 확장하면 검증과 피드백을 더 자주 받아 올바른 솔루션을 구축하는 방향으로 나아갈 수 있습니다.</p> </article> </div>  </main> <link rel="preload" as="image" href="https://github.com/gitsunmin.png"/><footer class="p-4 mt-4 flex flex-col gap-y-4 bg-background-footer text-foreground-footer"><div class="flex items-center gap-4 justify-cente w-full"><img src="https://github.com/gitsunmin.png" alt="logo" class="rounded-full size-10"/><span>Powered by Gitsunmin</span></div><ul class="flex gap-2 justify-end"><li><a href="https://github.com/gitsunmin" target="_blank" rel="noreferrer" class="text-blue-500 hover:underline">GitHub</a></li><li><a href="https://www.linkedin.com/in/gitsunmin/" target="_blank" rel="noreferrer" class="text-blue-500 hover:underline">LinkedIn</a></li></ul></footer>  </astro-slot><!--astro:end--></astro-island> </body></html>